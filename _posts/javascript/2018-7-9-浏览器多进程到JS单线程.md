---
layout: blog
javascript: true
background-image: http://img.hb.aicdn.com/01da1f1e0d9e5cb96dde24fb3d1c5fee6fda858e338f-WKMRmV_/fw/480
category: javascript
title: 浏览器多进程到JS单线程
tags:
- JS线程
---
## 区分线程和进程
> 浏览器是多进程的，每个进程又是多线程的；好比：进程是一个工厂，线程就是工厂里的工人，各自有各自有工作互不干扰，但是却共享工厂里的资源；
- 进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）
- 线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）
- [x] **tips**
- 不同进程之间也可以通信，不过代价较大
- 现在，一般通用的叫法：单线程与多线程，都是指在一个进程内的单和多。（所以核心还是得属于一个进程才行）

## 浏览器的多进程
- 主进程（Browser进程）
    1. 浏览器主进程只有一个
    2. 负责浏览器的界面显示；交互，历史的前进后退键
    3. 将Render进程中得到的Birmap，绘制到用户界面上
    4. 重要的网络资源下载；http请求下载跨域处理，和图片等文件的下载都是由他控制；
- GPU进程
    1. 用于3D渲染（一个浏览器最多1个该进程）
- 第三方插件进程
    1. 每种类型的插件对应一个进程，仅当使用该插件时才创建
- Render进程（内核进程***）
    1. 默认每个Tab页面一个进程，互不影响
    2. 页面渲染，脚本执行，事件处理等

## 浏览器多进程的优势

> 多进程相对于单进程的优势：

1. 避免单个page crash影响整个浏览器
2. 避免第三方插件crash影响整个浏览器
3. 多进程充分利用多核优势
4. 方便使用沙盒模型隔离插件等进程，提高浏览器稳定性

## 浏览器的内核渲染（前端页面的渲染部分）***
> 页面的渲染，JS的执行，事件的循环，都在这个进程内进行；

- GUI线程
    1. 负责渲染浏览器界面，解析HTML，CSS，构建DOM树和RenderObject树（注释1），布局和绘制等等；
    2. 当界面需要重绘（Repaint）或由于某种操作引发回流(reflow)时，该线程也会执行
    3. 注意，GUI渲染线程与JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起（相当于被冻结了），GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。
    
- JS线程
    1. 也称为JS内核，负责处理Javascript脚本程序。（例如V8引擎）
    2. JS引擎线程负责解析Javascript脚本，运行代码。
    3. JS引擎一直等待着任务队列中任务的到来，然后加以处理，一个Tab页（renderer进程）中无论什么时候都只有一个JS线程在运行JS程序
    4. 同样注意，GUI渲染线程与JS引擎线程是互斥的，所以如果JS执行的时间过长，这样就会造成页面的渲染不连贯，导致页面渲染加载阻塞。
    5. 
- 事件处理线程
    1. 不是JS引擎，用来控制事件循环（可以理解，JS引擎自己都忙不过来，需要浏览器另开线程协助）
    2. 当JS引擎执行代码块如setTimeOut时（也可来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件线程中
    3. 当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理
    4. 注意，由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）
- 定时器线程
    1. 传说中的setInterval与setTimeout所在线程
    2. 浏览器定时计数器并不是由JavaScript引擎计数的,（因为JavaScript引擎是单线程的, 如果处于阻塞线程状态就会影响记计时的准确）
    3. 因此通过单独线程来计时并触发定时（计时完毕后，添加到事件队列中，等待JS引擎空闲后执行）
    4. 注意，W3C在HTML标准中规定，规定要求setTimeout中低于4ms的时间间隔算为4ms。
- 异步http请求线程：
    1. 在XMLHttpRequest在连接后是通过浏览器新开一个线程请求
    2. 将检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将这个回调再放入事件队列中。再由JavaScript引擎执行。


### render进程中各线程的关系
#### GUI线程和JS线程互斥；
> 由于javascript也可以操作DOM，如果在渲染页面的同时还修改页面的DOM信息，那么渲染进程最终得到的页面就不一样了；因此为了防止渲染出现不可预期的结果，浏览器设置GUI渲染线程与JS引擎为互斥的关系，当JS引擎执行时GUI线程会被挂起，GUI更新则会被保存在一个队列中等到JS引擎线程空闲时立即被执行。
- [x] 从上边可以看出页面js阻塞页面的加载，js执行时间过长会影响GUI渲染页面；
#### 渲染线程GUI线程
1. 前期工作这里我先简化一下，后边在做具体的补充：
> 浏览器输入url，浏览器主进程接管，开一个下载线程，然后进行http请求（略去DNS查询，IP寻址等等操作），然后等待响应，获取内容，随后将内容通过RendererHost接口转交给Renderer进程-浏览器渲染流程开始
- [ ] 浏览器器内核拿到内容后，渲染大概可以划分成以下几个步骤：
1. 解析HTML树建立DOM树；
2. 将css代码解析成css规则树，在和DOM树结合生成Render树；
3. 布局render树（Layout/reflow），负责计算尺寸，位置计算
4. 绘制render树（paint），绘制页面像素信息
5. 浏览器会将各层的信息发送给GPU，GPU会将各层合成（composite），显示在屏幕上。

- [ ] load事件和DOMContentLoaded事件的先后
- load是页面的所有元素加载完毕，包括图片，样式，脚本
- DOMContentLoaded事件是页面的DOM加载完毕就触发

- [ ] css是否会阻碍dom树渲染
- css是由单独的下载线程异步下载的；
- css加载不会阻塞DOM树解析（异步加载时DOM照常构建）
- 但会阻塞render树渲染（渲染时需等css加载完毕，因为render树需要css信息）
> 因为你加载css的时候，可能会修改下面DOM节点的样式，如果css加载不阻塞render树渲染的话，那么当css加载完之后，render树可能又得重新重绘或者回流了，这就造成了一些没有必要的损耗。所以干脆就先把DOM树的结构先解析完，把可以做的工作做完，然后等你css加载完之后，在根据最终的样式来渲染render树，这种做法性能方面确实会比较好一点。

#### 普通图层和复合图层
> 适当利用复合图层会提升性能
- GPU中，各个复合图层是单独绘制的，所以互不影响，这也是为什么某些场景硬件加速效果一级棒
- 可以Chrome源码调试 -> More Tools -> Rendering -> Layer borders中看到，黄色的就是复合图层信息
- [x] 如何变成复合图层（硬件加速）
    - 最常用的方式：translate3d、translateZ；
    - opacity属性/过渡动画（需要动画执行的过程中才会创建合成层，动画没有开始或结束后元素还会回到之前的状态）；
    - video，iframe，canvas，webgl等元素；
    - 其它，譬如以前的flash插件；
    - 硬件加速时请使用index；
    
#### 从Event Loop谈JS的运行机制（js线程和事件触发线程）
1. JS分为同步任务和异步任务
2. 同步任务都在主线程上执行，形成一个执行栈
3. 主线程之外，事件触发线程管理着一个任务队列，只要异步任务有了运行结果，就在任务队列之中放置一个事件。
4. 一旦执行栈中的所有同步任务执行完毕（此时JS引擎空闲），系统就会读取任务队列，将可运行的异步任务添加到可执行栈中，开始执行。

#### 定时器线程
> 这里是内核单独开的一个线程来帮助js进行定时器的运算，满足触发条件的时候就会将触发的代码推进事件队列中；

#### macrotask与microtask
- [ ] macrotask（又称之为宏任务），可以理解是每次执行栈执行的代码就是一个宏任务（包括每次从事件队列中获取一个事件回调并放到执行栈中执行）每一个task会从头到尾将这个任务执行完毕，不会执行其它； 浏览器为了能够使得JS内部task与DOM任务能够有序的执行，会在一个task执行结束后，在下一个 task 执行开始前，对页面进行重新渲染（task->渲染->task->...）
- [ ] microtask（又称为微任务），可以理解是在当前 task 执行结束后立即执行的任务；也就是说，在当前task任务后，下一个task之前，在渲染之前；所以它的响应速度相比setTimeout（setTimeout是task）会更快，因为无需等渲染；也就是说，在某一个macrotask执行完后，就会将在它执行期间产生的所有microtask都执行完毕（在渲染前）

- [x] 分别很么样的场景会形成macrotask和microtask呢？
    - macrotask：主代码块，setTimeout，setInterval等（可以看到，事件队列中的每一个事件都是一个macrotask）
    - microtask：Promise.then，process.nextTick等


## Browser主进程和浏览器内核（Renderer进程）的通信过程
1. browser进程收到用户的请求，首先需要从下载页面所需要的资源，然后将任务通过renderHost借口传递给Render进程；
2. Render进程接受到任务，简单解释后，交给渲染线程，进行页面的渲染
3. 渲染线程接受到任务，开始渲染进程，加载并渲染网页，其中可能用到broeser进程来下载资源，和GPU来进行3D渲染；
4. 会有JS线程ca偶作DOM会影响回流，重绘；
5. 最后Render进程将渲染的结构返回给Browser进程
6. Browser进程渲染到浏览器上；


